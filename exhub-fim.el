;;; exhub-fim.el --- Code completion using LLM -*- lexical-binding: t; -*-

;;; Commentary:
;; LLM-powered code completion with dual modes:
;;
;; - Specialized prompts and various enhancements for chat-based LLMs
;;   on code completion tasks.
;; - Fill-in-the-middle (FIM) completion for compatible models
;;   (DeepSeek, Codestral, and some Ollama models).
;;
;; Exhub-fim supports multiple LLM providers (OpenAI, Claude, Gemini,
;; Codestral, Ollama, Llama.cpp, and OpenAI-compatible providers)
;;
;; You can use it with overlay-based ghost text via
;; `exhub-fim-show-suggestion' or selecting the candidates via
;; `exhub-fim-complete-with-minibuffer'.  You can toggle automatic
;; suggestion popup with `exhub-fim-auto-suggestion-mode'.

;;; Code:

(require 'plz)
(require 'dash)
(require 'cl-lib)

(defgroup exhub-fim nil
  "Exhub-fim group."
  :group 'applications)

(declare-function evil-emacs-state-p "evil-states")
(declare-function evil-insert-state-p "evil-states")
(declare-function consult--read "consult")
(declare-function consult--insertion-preview "consult")

(defcustom exhub-fim-auto-suggestion-debounce-delay 0.8
  "Debounce delay in seconds for auto-suggestions."
  :type 'number)

(defcustom exhub-fim-auto-suggestion-block-functions '(exhub-fim-evil-not-insert-state-p)
  "List of functions to determine whether auto-suggestions should be blocked.

Each function should return non-nil if auto-suggestions should be
blocked.  If any function in this list returns non-nil,
auto-suggestions will not be shown."
  :type '(repeat function))

(defcustom exhub-fim-auto-suggestion-throttle-delay 1.0
  "Minimum time in seconds between auto-suggestions."
  :type 'number)

(defface exhub-fim-suggestion-face
  '((t :inherit shadow))
  "Face used for displaying inline suggestions.")


(defvar-local exhub-fim--current-overlay nil
  "Overlay used for displaying the current suggestion.")


(defvar-local exhub-fim--last-point nil
  "Last known cursor position for suggestion overlay.")

(defvar-local exhub-fim--auto-last-point nil
  "Last known cursor position for auto-suggestion.")


(defvar-local exhub-fim--current-suggestions nil
  "List of current completion suggestions.")

(defvar-local exhub-fim--current-suggestion-index 0
  "Index of currently displayed suggestion.")

(defvar-local exhub-fim--current-requests nil
  "List of current active request processes for this buffer.")


(defvar-local exhub-fim--last-auto-suggestion-time nil
  "Timestamp of last auto-suggestion.")

(defvar-local exhub-fim--debounce-timer nil
  "Timer for debouncing auto-suggestions.")

(defvar exhub-fim-buffer-name "*exhub-fim*" "The basename for exhub-fim buffers.")

(defcustom exhub-fim-provider 'openai-fim-compatible
  "The provider to use for code completion.
Must be one of the supported providers: codestral, openai, claude, etc."
  :type '(choice (const :tag "Codestral" codestral)
                 (const :tag "OpenAI" openai)
                 (const :tag "Claude" claude)
                 (const :tag "OpenAI Compatible" openai-compatible)
                 (const :tag "OpenAI FIM Compatible" openai-fim-compatible)
                 (const :tag "Gemini" gemini)))

(defcustom exhub-fim-context-window 16000
  "The maximum total characters of the context before and after cursor.
This limits how much surrounding code is sent to the LLM for context.
The default is 16000 characters which would roughly equate 4000
tokens."
  :type 'integer)

(defcustom exhub-fim-context-ratio 0.75
  "Ratio of context before cursor vs after cursor.
When the total characters exceed the context window, this ratio
determines how much context to keep before vs after the cursor.  A
larger ratio means more context before the cursor will be used."
  :type 'float)

(defcustom exhub-fim-request-timeout 3
  "Maximum timeout in seconds for sending completion requests."
  :type 'integer)

(defcustom exhub-fim-add-single-line-entry t
  "Whether to create additional single-line completion items.
When non-nil and a completion item has multiple lines, create another
completion item containing only its first line."
  :type 'boolean)

(defcustom exhub-fim-after-cursor-filter-length 15
  "Length of context after cursor used to filter completion text.

Defines the length of non-whitespace context after the cursor used to
filter completion text.  Set to 0 to disable filtering.

Example: With after_cursor_filter_length = 3 and context: \"def
fib(n):\\n|\\n\\nfib(5)\" (where | represents cursor position), if the
completion text contains \"fib\", then \"fib\" and subsequent text
will be removed.  This setting filters repeated text generated by the
LLM.  A large value (e.g., 15) is recommended to avoid false
positives."
  :type 'integer)

(defcustom exhub-fim-n-completions 3
  "Number of completion items.
For FIM model, this is the number of requests to send.  For chat LLM ,
this is the number of completions encoded as part of the prompt.  Note
that when `exhub-fim-add-single-line-entry` is true, the actual number of
returned items may exceed this value.  Additionally, the LLM cannot
guarantee the exact number of completion items specified, as this
parameter serves only as a prompt guideline.  The default is `3`."
  :type 'integer)

(defvar exhub-fim-default-prompt-prefix-first
  "You are the backend of an AI-powered code completion engine. Your task is to
provide code suggestions based on the user's input. The user's code will be
enclosed in markers:

- `<contextAfterCursor>`: Code context after the cursor
- `<cursorPosition>`: Current cursor location
- `<contextBeforeCursor>`: Code context before the cursor
"
  "The default prefix-first style prompt for exhub-fim completion.")

(defvar exhub-fim-default-prompt
  (concat exhub-fim-default-prompt-prefix-first
          "
Note that the user's code will be prompted in reverse order: first the code
after the cursor, then the code before the cursor.
") "The default prompt for exhub-fim completion.")

(defvar exhub-fim-default-guidelines
  "Guidelines:
1. Offer completions after the `<cursorPosition>` marker.
2. Make sure you have maintained the user's existing whitespace and indentation.
   This is REALLY IMPORTANT!
3. Provide multiple completion options when possible.
4. Return completions separated by the marker <endCompletion>.
5. The returned message will be further parsed and processed. DO NOT include
   additional comments or markdown code block fences. Return the result directly.
6. Keep each completion option concise, limiting it to a single line or a few lines.
7. Create entirely new code completion that DO NOT REPEAT OR COPY any user's existing code around <cursorPosition>."
  "The default guidelines for exhub-fim completion.")

(defvar exhub-fim-default-n-completion-template
  "8. Provide at most %d completion items."
  "The default prompt for exhub-fim for number of completions request.")

(defvar exhub-fim-default-system-template
  "{{{:prompt}}}\n{{{:guidelines}}}\n{{{:n-completions-template}}}"
  "The default template for exhub-fim system template.")

(defvar exhub-fim-default-chat-input-template
  "{{{:language-and-tab}}}
<contextAfterCursor>
{{{:context-after-cursor}}}
<contextBeforeCursor>
{{{:context-before-cursor}}}<cursorPosition>"
  "The default template for exhub-fim chat input.")

(defvar exhub-fim-default-chat-input-template-prefix-first
  "{{{:language-and-tab}}}
<contextBeforeCursor>
{{{:context-before-cursor}}}<cursorPosition>
<contextAfterCursor>
{{{:context-after-cursor}}}"
  "The default prefix-first style template for exhub-fim chat input.")

(defvar exhub-fim-default-fewshots
  `((:role "user"
           :content "# language: python
<contextAfterCursor>

fib(5)
<contextBeforeCursor>
def fibonacci(n):
    <cursorPosition>")
    (:role "assistant"
           :content "    '''
    Recursive Fibonacci implementation
    '''
    if n < 2:
        return n
    return fib(n - 1) + fib(n - 2)
<endCompletion>
    '''
    Iterative Fibonacci implementation
    '''
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a
<endCompletion>
")))

(defvar exhub-fim-default-fewshots-prefix-first
  `((:role "user"
           :content "# language: python
<contextBeforeCursor>
def fibonacci(n):
    <cursorPosition>
<contextAfterCursor>

fib(5)")
    ,(cadr exhub-fim-default-fewshots)))

(defvar exhub-fim-claude-options
  `(:model "claude-3-5-haiku-20241022"
           :max_tokens 512
           :api-key "ANTHROPIC_API_KEY"
           :system
           (:template exhub-fim-default-system-template
                      :prompt exhub-fim-default-prompt
                      :guidelines exhub-fim-default-guidelines
                      :n-completions-template exhub-fim-default-n-completion-template)
           :fewshots exhub-fim-default-fewshots
           :chat-input
           (:template exhub-fim-default-chat-input-template
                      :language-and-tab exhub-fim--default-chat-input-language-and-tab-function
                      :context-before-cursor exhub-fim--default-chat-input-before-cursor-function
                      :context-after-cursor exhub-fim--default-chat-input-after-cursor-function)
           :optional nil)
  "Config options for Exhub-fim Claude provider.")

(defvar exhub-fim-openai-options
  `(:model "gpt-4o-mini"
           :api-key "OPENAI_API_KEY"
           :system
           (:template exhub-fim-default-system-template
                      :prompt exhub-fim-default-prompt
                      :guidelines exhub-fim-default-guidelines
                      :n-completions-template exhub-fim-default-n-completion-template)
           :fewshots exhub-fim-default-fewshots
           :chat-input
           (:template exhub-fim-default-chat-input-template
                      :language-and-tab exhub-fim--default-chat-input-language-and-tab-function
                      :context-before-cursor exhub-fim--default-chat-input-before-cursor-function
                      :context-after-cursor exhub-fim--default-chat-input-after-cursor-function)
           :optional nil)
  "Config options for Exhub-fim OpenAI provider.")

(defvar exhub-fim-codestral-options
  '(:model "codestral-latest"
           :end-point "https://codestral.mistral.ai/v1/fim/completions"
           :api-key "CODESTRAL_API_KEY"
           :template (:prompt exhub-fim--default-fim-prompt-function
                              :suffix exhub-fim--default-fim-suffix-function)
           :optional nil)
  "Config options for Exhub-fim Codestral provider.")

(defvar exhub-fim-openai-compatible-options
  `(:end-point "http://127.0.0.1:9069/openai/v1/chat/completions"
               :api-key "OPENAI_API_KEY"
               :model "gpt-4o-mini"
               :system
               (:template exhub-fim-default-system-template
                          :prompt exhub-fim-default-prompt
                          :guidelines exhub-fim-default-guidelines
                          :n-completions-template exhub-fim-default-n-completion-template)
               :fewshots exhub-fim-default-fewshots
               :chat-input
               (:template exhub-fim-default-chat-input-template
                          :language-and-tab exhub-fim--default-chat-input-language-and-tab-function
                          :context-before-cursor exhub-fim--default-chat-input-before-cursor-function
                          :context-after-cursor exhub-fim--default-chat-input-after-cursor-function)
               :optional nil)
  "Config options for Exhub-fim OpenAI compatible provider.")

(defvar exhub-fim-openai-fim-compatible-options
  '(:model "deepseek-chat"
           :end-point "https://api.deepseek.com/beta/completions"
           :api-key "DEEPSEEK_API_KEY"
           :name "Deepseek"
           :template (:prompt exhub-fim--default-fim-prompt-function
                              :suffix exhub-fim--default-fim-suffix-function)
           :optional nil)
  "Config options for Exhub-fim OpenAI FIM compatible provider.")

(defvar exhub-fim-gemini-options
  `(:model "gemini-2.0-flash"
           :api-key "GEMINI_API_KEY"
           :system
           (:template exhub-fim-default-system-template
                      :prompt exhub-fim-default-prompt-prefix-first
                      :guidelines exhub-fim-default-guidelines
                      :n-completions-template exhub-fim-default-n-completion-template)
           :fewshots exhub-fim-default-fewshots-prefix-first
           :chat-input
           (:template exhub-fim-default-chat-input-template-prefix-first
                      :language-and-tab exhub-fim--default-chat-input-language-and-tab-function
                      :context-before-cursor exhub-fim--default-chat-input-before-cursor-function
                      :context-after-cursor exhub-fim--default-chat-input-after-cursor-function)
           :optional nil)
  "Config options for Exhub-fim Gemini provider.")


(defun exhub-fim-evil-not-insert-state-p ()
  "Return non-nil if evil is loaded and not in insert or Emacs state."
  (and (bound-and-true-p evil-local-mode)
       (not (or (evil-insert-state-p)
                (evil-emacs-state-p)))))

(defun exhub-fim-set-optional-options (options key val &optional field)
  "Set the value of KEY in the FIELD of OPTIONS to VAL.
If FIELD is not provided, it defaults to :optional.  If VAL is nil,
then remove KEY from OPTIONS.  This helper function simplifies setting
values in a two-level nested plist structure."
  (let ((field (or field :optional)))
    (if val
        (setf (plist-get options field)
              (plist-put (plist-get options field) key val))
      (setf (plist-get options field)
            (map-delete (plist-get options field) key)))))

(defun exhub-fim--eval-value (value)
  "Eval a VALUE for exhub-fim.
If value is a function (either lambda or a callable symbol), eval the
function (with no argument) and return the result.  Else if value is a
symbol, return its value.  Else return itself."
  (cond ((functionp value) (funcall value))
        ((and (symbolp value) (boundp value)) (symbol-value value))
        (t value)))

(defun exhub-fim--cancel-requests ()
  "Cancel all current exhub-fim requests for this buffer."
  (when exhub-fim--current-requests
    (dolist (proc exhub-fim--current-requests)
      (when (process-live-p proc)
        (exhub-fim--log (format "%s process killed" (prin1-to-string proc)))
        (delete-process proc)))
    (setq exhub-fim--current-requests nil)))

(defun exhub-fim--cleanup-suggestion (&optional no-cancel)
  "Remove the current suggestion overlay.
Also cancel any pending requests unless NO-CANCEL is t."
  (unless no-cancel
    (exhub-fim--cancel-requests))
  (when exhub-fim--current-overlay
    (delete-overlay exhub-fim--current-overlay)
    (setq exhub-fim--current-overlay nil)
    (exhub-fim-active-mode -1))
  (remove-hook 'post-command-hook #'exhub-fim--on-cursor-moved t)
  (setq exhub-fim--last-point nil))

(defun exhub-fim--cursor-moved-p ()
  "Check if cursor moved from last suggestion position."
  (and exhub-fim--last-point
       (not (eq exhub-fim--last-point (point)))))

(defun exhub-fim--on-cursor-moved ()
  "Exhub-fim event on cursor moved."
  (when (exhub-fim--cursor-moved-p)
    (exhub-fim--cleanup-suggestion)))

(defun exhub-fim--display-suggestion (suggestions &optional index)
  "Display suggestion from SUGGESTIONS at INDEX using an overlay at point."
  ;; we only cancel requests when cursor is moved. Because the
  ;; completion items may be accumulated during multiple concurrent
  ;; curl requests.
  (exhub-fim--cleanup-suggestion t)
  (add-hook 'post-command-hook #'exhub-fim--on-cursor-moved nil t)
  (when-let* ((suggestions suggestions)
              (cursor-not-moved (not (exhub-fim--cursor-moved-p)))
              (index (or index 0))
              (total (length suggestions))
              (suggestion (nth index suggestions))
              ;; Ensure the overlay appears after the cursor If
              ;; point is not at end-of-line, offset the overlay
              ;; position by 1
              (ov-point (if (eolp) (point) (1+ (point))))
              (ov (make-overlay ov-point ov-point)))
    (setq exhub-fim--current-suggestions suggestions
          exhub-fim--current-suggestion-index index
          exhub-fim--last-point (point))
    ;; HACK: Adapted from copilot.el We add a 'cursor text property to the
    ;; first character of the suggestion to simulate the visual effect of
    ;; placing the overlay after the cursor
    (put-text-property 0 1 'cursor t suggestion)
    (overlay-put ov 'after-string
                 (propertize
                  (format "%s%s"
                          suggestion
                          (if (= total exhub-fim-n-completions 1) ""
                            (format " (%d/%d)" (1+ index) total)))
                  'face 'exhub-fim-suggestion-face))
    (overlay-put ov 'exhub-fim t)
    (setq exhub-fim--current-overlay ov)
    (exhub-fim-active-mode 1)))

;;;###autoload
(defun exhub-fim-next-suggestion ()
  "Cycle to next suggestion."
  (interactive)
  (if (and exhub-fim--current-suggestions
           exhub-fim--current-overlay)
      (let ((next-index (mod (1+ exhub-fim--current-suggestion-index)
                             (length exhub-fim--current-suggestions))))
        (exhub-fim--display-suggestion exhub-fim--current-suggestions next-index))
    (exhub-fim-show-suggestion)))

;;;###autoload
(defun exhub-fim-previous-suggestion ()
  "Cycle to previous suggestion."
  (interactive)
  (if (and exhub-fim--current-suggestions
           exhub-fim--current-overlay)
      (let ((prev-index (mod (1- exhub-fim--current-suggestion-index)
                             (length exhub-fim--current-suggestions))))
        (exhub-fim--display-suggestion exhub-fim--current-suggestions prev-index))
    (exhub-fim-show-suggestion)))

;;;###autoload
(defun exhub-fim-show-suggestion ()
  "Show code suggestion using overlay at point."
  (interactive)
  (exhub-fim--cleanup-suggestion)
  (setq exhub-fim--last-point (point))
  (let ((current-buffer (current-buffer))
        (available-p-fn (intern (format "exhub-fim--%s-available-p" exhub-fim-provider)))
        (complete-fn (intern (format "exhub-fim--%s-complete" exhub-fim-provider)))
        (context (exhub-fim--get-context)))
    (unless (funcall available-p-fn)
      (exhub-fim--log (format "Exhub-fim provider %s is not available" exhub-fim-provider))
      (error "Exhub-fim provider %s is not available" exhub-fim-provider))
    (funcall complete-fn
             context
             (lambda (items)
               (setq items (-distinct items))
               (with-current-buffer current-buffer
                 (when (and items (not (exhub-fim--cursor-moved-p)))
                   (exhub-fim--display-suggestion items 0)))))))

(defun exhub-fim--log (message &optional message-p)
  "Log exhub-fim messages into `exhub-fim-buffer-name'.
Also print the MESSAGE when MESSAGE-P is t."
  (with-current-buffer (get-buffer-create exhub-fim-buffer-name)
    (goto-char (point-max))
    (insert (format "%s %s\n" message (format-time-string "%Y-%02m-%02d %02H:%02M:%02S")))
    (when message-p
      (message "%s" message))))

(defun exhub-fim--add-tab-comment ()
  "Add comment string for tab use into the prompt."
  (if-let* ((language-p (derived-mode-p 'prog-mode 'text-mode 'conf-mode))
            (commentstring (format "%s %%s%s"
                                   (or (replace-regexp-in-string "^%" "%%" comment-start) "#")
                                   (or comment-end ""))))
      (if indent-tabs-mode
          (format commentstring "indentation: use \t for a tab")
        (format commentstring (format "indentation: use %d spaces for a tab" tab-width)))
    ""))

(defun exhub-fim--add-language-comment ()
  "Add comment string for language use into the prompt."
  (if-let* ((language-p (derived-mode-p 'prog-mode 'text-mode 'conf-mode))
            (mode (symbol-name major-mode))
            (mode (replace-regexp-in-string "-ts-mode" "" mode))
            (mode (replace-regexp-in-string "-mode" "" mode))
            (commentstring (format "%s %%s%s"
                                   (or (replace-regexp-in-string "^%" "%%" comment-start) "#")
                                   (or comment-end ""))))
      (format commentstring (concat "language: " mode))
    ""))

(defun exhub-fim--add-single-line-entry (data)
  "Add single line entry into the DATA."
  (cl-loop
   for item in data
   when (stringp item)
   append (list (car (split-string item "\n"))
                item)))

(defun exhub-fim--remove-spaces (items)
  "Remove trailing and leading spaces in each item in ITEMS."
  ;; Emacs use \\` and \\' to match the beginning/end of the string,
  ;; ^ and $ are used to match bol or eol
  (setq items (mapcar (lambda (x)
                        (if (or (equal x "")
                                (string-match "\\`[\s\t\n]+\\'" x))
                            nil
                          (string-trim x)))
                      items)
        items (seq-filter #'identity items)))

(defun exhub-fim--get-context ()
  "Get the context for exhub-fim completion."
  (let* ((point (point))
         (n-chars-before point)
         (point-max (point-max))
         (n-chars-after (- point-max point))
         (before-start (point-min))
         (after-end point-max)
         (is-incomplete-before nil)
         (is-incomplete-after nil))
    ;; Calculate context window boundaries before extracting text
    (when (>= (+ n-chars-before n-chars-after) exhub-fim-context-window)
      (cond ((< n-chars-before (* exhub-fim-context-ratio exhub-fim-context-window))
             ;; If context before cursor does not exceed context-window,
             ;; only limit after-cursor content
             (setq after-end (+ point (- exhub-fim-context-window n-chars-before))
                   is-incomplete-after t))
            ((< n-chars-after (* (- 1 exhub-fim-context-ratio) exhub-fim-context-window))
             ;; If context after cursor does not exceed context-window,
             ;; limit before-cursor content
             (setq before-start (- point (- exhub-fim-context-window n-chars-after))
                   is-incomplete-before t))
            (t
             ;; At middle of file, use ratio to determine both boundaries
             (setq is-incomplete-before t
                   is-incomplete-after t
                   after-end (+ point (floor (* exhub-fim-context-window (- 1 exhub-fim-context-ratio))))
                   before-start (+ (point-min)
                                   (max 0 (- n-chars-before
                                             (floor (* exhub-fim-context-window exhub-fim-context-ratio)))))))))
    `(:before-cursor ,(buffer-substring-no-properties before-start point)
                     :after-cursor ,(buffer-substring-no-properties point after-end)
                     :language-and-tab ,(format "%s\n%s" (exhub-fim--add-language-comment) (exhub-fim--add-tab-comment))
                     :is-incomplete-before ,is-incomplete-before
                     :is-incomplete-after ,is-incomplete-after)))

(defun exhub-fim--make-chat-llm-shot (context options)
  "Build the final chat input for chat llm.
CONTEXT is read from current buffer content.
OPTIONS should be the provider options plist."
  (let* ((chat-input (copy-tree (plist-get options :chat-input)))
         (template (exhub-fim--eval-value (plist-get chat-input :template)))
         (parts nil))
    ;; Remove template from options to avoid infinite recursion
    (setq chat-input (plist-put chat-input :template nil))
    ;; Use cl-loop for better control flow
    (cl-loop with last-pos = 0
             for match = (string-match "{{{\\(.+?\\)}}}" template last-pos)
             until (not match)
             for start-pos = (match-beginning 0)
             for end-pos = (match-end 0)
             for key = (match-string 1 template)
             do
             ;; Add text before placeholder
             (when (> start-pos last-pos)
               (push (substring template last-pos start-pos) parts))
             ;; Get and add replacement value
             (when-let* ((repl-fn (plist-get chat-input (intern key)))
                         (value (funcall repl-fn context)))
               (push value parts))
             (setq last-pos end-pos)
             finally
             ;; Add remaining text after last match
             (push (substring template last-pos) parts))
    ;; Join parts in reverse order
    (apply #'concat (nreverse parts))))

(defun exhub-fim--make-context-filter-sequence (context len)
  "Create a filtering string based on CONTEXT with maximum length LEN."
  (if-let* ((is-string (stringp context))
            (is-positive (> len 0))
            (context (replace-regexp-in-string "\\`[\s\t\n]+" "" context))
            (should-filter (>= (length context) len))
            (context (substring context 0 len))
            (context (replace-regexp-in-string "[\s\t\n]+\\'" "" context)))
      context
    ""))

(defun exhub-fim--filter-text (text sequence)
  "Remove the SEQUENCE and the rest part from TEXT."
  (cond
   ((or (null sequence) (null text)) text)
   ((equal sequence "") text)
   (t
    (let ((start (string-match-p (regexp-quote sequence) text)))
      (if start
          (substring text 0 start)
        text)))))

(defun exhub-fim--filter-sequence-in-items (items sequence)
  "For each item in ITEMS, apply `exhub-fim--filter-text' with SEQUENCE."
  (mapcar (lambda (x) (exhub-fim--filter-text x sequence))
          items))

(defun exhub-fim--filter-context-sequence-in-items (items context)
  "Apply the filter sequence in each item in ITEMS.
The filter sequence is obtained from CONTEXT."
  (exhub-fim--filter-sequence-in-items
   items (exhub-fim--make-context-filter-sequence
          (plist-get context :after-cursor)
          exhub-fim-after-cursor-filter-length)))

(defun exhub-fim--stream-decode (response get-text-fn)
  "Decode the RESPONSE using GET-TEXT-FN."
  (setq response (split-string response "[\r]?\n"))
  (let (result)
    (dolist (line response)
      (if-let* ((json (ignore-errors
                        (json-parse-string
                         (replace-regexp-in-string "^data: " "" line)
                         :object-type 'plist :array-type 'list)))
                (text (ignore-errors
                        (funcall get-text-fn json))))
          (when (and (stringp text)
                     (not (equal text "")))
            (push text result))))
    (setq result (apply #'concat (nreverse result)))
    (if (equal result "")
        (progn (exhub-fim--log (format "Exhub-fim returns no text for streaming: %s" response))
               nil)
      result)))

(defmacro exhub-fim--make-process-stream-filter (response)
  "Store the data into RESPONSE which should hold a plain list."
  (declare (debug (gv-place)))
  `(lambda (proc text)
     (funcall #'internal-default-process-filter proc text)
     ;; (setq ,response (append ,response (list text)))
     (push text ,response)))

(defun exhub-fim--stream-decode-raw (response get-text-fn)
  "Decode the raw stream used by exhub-fim.

RESPONSE will be stored in the temp variable create by
`exhub-fim--make-process-stream-filter' parsed by GET-TEXT-FN."
  (when-let* ((response (nreverse response))
              (response (apply #'concat response)))
    (exhub-fim--stream-decode response get-text-fn)))

(defun exhub-fim--handle-chat-completion-timeout (context err response get-text-fn name callback)
  "Handle the timeout error for chat completion.
This function will decode and send the partial complete response to
the callback, and log the error.  CONTEXT, ERR, RESPONSE, GET-TEXT-FN,
NAME, CALLBACK are used to deliver partial completion items and log
the errors."
  (if (equal (car (plz-error-curl-error err)) 28)
      (progn
        (exhub-fim--log (format "%s Request timeout" name))
        (when-let* ((result (exhub-fim--stream-decode-raw response get-text-fn))
                    (completion-items (exhub-fim--parse-completion-itmes-default result))
                    (completion-items (exhub-fim--filter-context-sequence-in-items
                                       completion-items
                                       context))
                    (completion-items (exhub-fim--remove-spaces completion-items)))
          (funcall callback completion-items)))
    (exhub-fim--log (format "An error occured when sending request to %s" name))
    (exhub-fim--log err)))

(defmacro exhub-fim--with-temp-response (&rest body)
  "Execute BODY with a temporary response collection.
This macro creates a local variable `--response--' that can be used to
collect process output within the BODY.  It's designed to work in
conjunction with `exhub-fim--make-process-stream-filter'.  The
`--response--' variable is initialized as an empty list and can be
used to accumulate text output from a process.  After execution,
`--response--' will contain the collected responses in reverse order."
  (declare (debug t) (indent 0))
  `(let (--response--) ,@body))

;;;###autoload
(defun exhub-fim-accept-suggestion ()
  "Accept the current overlay suggestion."
  (interactive)
  (when (and exhub-fim--current-suggestions
             exhub-fim--current-overlay)
    (let ((suggestion (nth exhub-fim--current-suggestion-index
                           exhub-fim--current-suggestions)))
      (exhub-fim--cleanup-suggestion)
      (insert suggestion))))

;;;###autoload
(defun exhub-fim-dismiss-suggestion ()
  "Dismiss the current overlay suggestion."
  (interactive)
  (exhub-fim--cleanup-suggestion))

;;;###autoload
(defun exhub-fim-accept-suggestion-line (&optional n)
  "Accept N lines of the current suggestion.
When called interactively with a numeric prefix argument, accept that
many lines.  Without a prefix argument, accept only the first line."
  (interactive "p")
  (when (and exhub-fim--current-suggestions
             exhub-fim--current-overlay)
    (let* ((suggestion (nth exhub-fim--current-suggestion-index
                            exhub-fim--current-suggestions))
           (lines (split-string suggestion "\n"))
           (n (or n 1))
           (selected-lines (seq-take lines n)))
      (exhub-fim--cleanup-suggestion)
      (insert (string-join selected-lines "\n")))))

;;;###autoload
(defun exhub-fim-complete-with-minibuffer ()
  "Complete using minibuffer interface."
  (interactive)
  (let ((current-buffer (current-buffer))
        (available-p-fn (intern (format "exhub-fim--%s-available-p" exhub-fim-provider)))
        (complete-fn (intern (format "exhub-fim--%s-complete" exhub-fim-provider)))
        (context (exhub-fim--get-context))
        (completing-read (lambda (items) (completing-read "Complete: " items nil t)))
        (consult--read (lambda (items)
                         (consult--read
                          items
                          :prompt "Complete: "
                          :require-match t
                          :state (consult--insertion-preview (point) (point))))))
    (unless (funcall available-p-fn)
      (exhub-fim--log (format "Exhub-fim provider %s is not available" exhub-fim-provider))
      (error "Exhub-fim provider %s is not available" exhub-fim-provider))
    (funcall complete-fn
             context
             (lambda (items)
               (with-current-buffer current-buffer
                 (setq items (if exhub-fim-add-single-line-entry
                                 (exhub-fim--add-single-line-entry items)
                               items)
                       items (-distinct items))
                 ;; close current minibuffer session, if any
                 (when (active-minibuffer-window)
                   (abort-recursive-edit))
                 (when-let* ((items)
                             (selected (funcall
                                        (if (require 'consult nil t) consult--read completing-read)
                                        items)))
                   (unless (string-empty-p selected)
                     (insert selected))))))))

(defun exhub-fim--get-api-key (api-key)
  "Get the api-key from API-KEY.
API-KEY can be a string (as an environment variable) or a function.
Return nil if not exists or is an empty string."
  (let ((key (if (stringp api-key)
                 (getenv api-key)
               (when (functionp api-key)
                 (funcall api-key)))))
    (when (or (null key)
              (string-empty-p key))
      (exhub-fim--log
       (if (stringp api-key)
           (format "%s is not a valid environment variable.
If using ollama you can just set it to 'TERM'." api-key)
         "The api-key function returns nil or returns an empty string")))
    (and (not (equal key "")) key)))


(defun exhub-fim--codestral-available-p ()
  "Check if codestral if available."
  (exhub-fim--get-api-key (plist-get exhub-fim-codestral-options :api-key)))

(defun exhub-fim--openai-available-p ()
  "Check if openai if available."
  (exhub-fim--get-api-key (plist-get exhub-fim-openai-options :api-key)))

(defun exhub-fim--claude-available-p ()
  "Check if claude is available."
  (exhub-fim--get-api-key (plist-get exhub-fim-claude-options :api-key)))

(defun exhub-fim--openai-compatible-available-p ()
  "Check if the specified openai-compatible service is available."
  (when-let* ((options exhub-fim-openai-compatible-options)
              (env-var (plist-get options :api-key))
              (end-point (plist-get options :end-point))
              (model (plist-get options :model)))
    (exhub-fim--get-api-key env-var)))

(defun exhub-fim--openai-fim-compatible-available-p ()
  "Check if the specified openai-fim-compatible service is available."
  (when-let* ((options exhub-fim-openai-fim-compatible-options)
              (env-var (plist-get options :api-key))
              (name (plist-get options :name))
              (end-point (plist-get options :end-point))
              (model (plist-get options :model)))
    (exhub-fim--get-api-key env-var)))

(defun exhub-fim--gemini-available-p ()
  "Check if gemini is available."
  (exhub-fim--get-api-key (plist-get exhub-fim-gemini-options :api-key)))

(defun exhub-fim--parse-completion-itmes-default (items)
  "Parse ITEMS into a list of completion entries."
  (split-string items "<endCompletion>"))

(defun exhub-fim--make-system-prompt (template &optional n-completions)
  "Create system prompt used in chat LLM from TEMPLATE and N-COMPLETIONS."
  (let* ((tmpl (plist-get template :template))
         (tmpl (exhub-fim--eval-value tmpl))
         (n-completions (or n-completions exhub-fim-n-completions 1))
         (n-completions-template (plist-get template :n-completions-template))
         (n-completions-template (exhub-fim--eval-value n-completions-template))
         (n-completions-template (if (stringp n-completions-template)
                                     (format n-completions-template n-completions)
                                   "")))
    (setq tmpl (replace-regexp-in-string "{{{:n-completions-template}}}"
                                         n-completions-template
                                         tmpl)
          tmpl (replace-regexp-in-string
                "{{{\\([^{}]+\\)}}}"
                (lambda (str)
                  (exhub-fim--eval-value (plist-get template (intern (match-string 1 str)))))
                tmpl)
          ;; replace placeholders that are not replaced
          tmpl (replace-regexp-in-string "{{{.*}}}" "" tmpl))))

(defun exhub-fim--openai-fim-complete-base (options get-text-fn context callback)
  "The base function to complete code with openai fim API.
OPTIONS are the provider options.  GET-TEXT-FN are the function to get
the completion items from json.  CONTEXT is to be used to build the
prompt.  CALLBACK is the function to be called when completion items
arrive."
  (let ((total-try (or exhub-fim-n-completions 1))
        (name (plist-get options :name))
        (body (json-serialize
               `(,@(plist-get options :optional)
                 :stream t
                 :model ,(plist-get options :model)
                 :prompt ,(funcall (--> options
                                        (plist-get it :template)
                                        (plist-get it :prompt))
                                   context)
                 ,@(when-let* ((suffix-fn (--> options
                                               (plist-get it :template)
                                               (plist-get it :suffix))))
                     (list :suffix (funcall suffix-fn context))))))
        completion-items)
    (dotimes (_ total-try)
      (exhub-fim--with-temp-response
       (push
        (plz 'post (plist-get options :end-point)
             :headers `(("Content-Type" . "application/json")
                        ("Accept" . "application/json")
                        ("Authorization" . ,(concat "Bearer " (exhub-fim--get-api-key (plist-get options :api-key)))))
             :timeout exhub-fim-request-timeout
             :body body
             :as 'string
             :filter (exhub-fim--make-process-stream-filter --response--)
             :then
             (lambda (json)
               (when-let* ((result (exhub-fim--stream-decode json get-text-fn)))
                 ;; insert the current result into the completion items list
                 (push result completion-items))
               (setq completion-items (exhub-fim--filter-context-sequence-in-items
                                       completion-items
                                       context))
               (setq completion-items (exhub-fim--remove-spaces completion-items))
               (funcall callback completion-items))
             :else
             (lambda (err)
               (if (equal (car (plz-error-curl-error err)) 28)
                   (progn
                     (exhub-fim--log (format "%s Request timeout" name))
                     (when-let* ((result (exhub-fim--stream-decode-raw --response-- get-text-fn)))
                       (push result completion-items)))
                 (exhub-fim--log (format "An error occured when sending request to %s" name))
                 (exhub-fim--log err))
               (setq completion-items
                     (exhub-fim--filter-context-sequence-in-items
                      completion-items
                      context))
               (setq completion-items (exhub-fim--remove-spaces completion-items))
               (funcall callback completion-items)))
        exhub-fim--current-requests)))))

(defun exhub-fim--codestral-complete (context callback)
  "Complete code with codestral.
CONTEXT and CALLBACK will be passed to the base function."
  (exhub-fim--openai-fim-complete-base
   (plist-put (copy-tree exhub-fim-codestral-options) :name "Codestral")
   #'exhub-fim--openai-get-text-fn
   context
   callback))

(defun exhub-fim--openai-fim-compatible-complete (context callback)
  "Complete code with openai fim API.
CONTEXT and CALLBACK will be passed to the base function."
  (exhub-fim--openai-fim-complete-base
   (copy-tree exhub-fim-openai-fim-compatible-options)
   #'exhub-fim--openai-fim-get-text-fn
   context
   callback))

(defun exhub-fim--openai-fim-get-text-fn (json)
  "Function to get the completion from a JSON object for openai-fim compatible."
  (--> json
       (plist-get it :choices)
       car
       (plist-get it :text)))

(defun exhub-fim--openai-get-text-fn (json)
  "Function to get the completion from a JSON object for openai compatible service."
  (--> json
       (plist-get it :choices)
       car
       (plist-get it :delta)
       (plist-get it :content)))

(defun exhub-fim--openai-complete-base (options context callback)
  "The base function to complete code with openai API.
OPTIONS are the provider options.  the completion items from json.
CONTEXT is to be used to build the prompt.  CALLBACK is the function
to be called when completion items arrive."
  (exhub-fim--with-temp-response
   (push
    (plz 'post (plist-get options :end-point)
         :headers
         `(("Content-Type" . "application/json")
           ("Accept" . "application/json")
           ("Authorization" . ,(concat "Bearer " (exhub-fim--get-api-key (plist-get options :api-key)))))
         :timeout exhub-fim-request-timeout
         :body
         (json-serialize
          `(,@(plist-get options :optional)
            :stream t
            :model ,(plist-get options :model)
            :messages ,(vconcat
                        `((:role "system"
                                 :content ,(exhub-fim--make-system-prompt (plist-get options :system)))
                          ,@(exhub-fim--eval-value (plist-get options :fewshots))
                          (:role "user"
                                 :content ,(exhub-fim--make-chat-llm-shot context options))))))
         :as 'string
         :filter (exhub-fim--make-process-stream-filter --response--)
         :then
         (lambda (json)
           (when-let* ((result (exhub-fim--stream-decode json #'exhub-fim--openai-get-text-fn))
                       (completion-items (exhub-fim--parse-completion-itmes-default result))
                       (completion-items (exhub-fim--filter-context-sequence-in-items
                                          completion-items
                                          context))
                       (completion-items (exhub-fim--remove-spaces completion-items)))
             ;; insert the current result into the completion items list
             (funcall callback completion-items)))
         :else
         (lambda (err)
           (exhub-fim--handle-chat-completion-timeout
            context err --response-- #'exhub-fim--openai-get-text-fn "OpenAI" callback)))
    exhub-fim--current-requests)))

(defun exhub-fim--openai-complete (context callback)
  "Complete code with OpenAI.
CONTEXT and CALLBACK will be passed to the base function."
  (exhub-fim--openai-complete-base
   (--> (copy-tree exhub-fim-openai-options)
        (plist-put it :end-point "https://api.openai.com/v1/chat/completions"))
   context callback))

(defun exhub-fim--openai-compatible-complete (context callback)
  "Complete code with OpenAI compatible service.
CONTEXT and CALLBACK will be passed to the base function."
  (exhub-fim--openai-complete-base
   (copy-tree exhub-fim-openai-compatible-options) context callback))

(defun exhub-fim--claude-get-text-fn (json)
  "Function to get the completion from a JSON object for claude."
  (--> json
       (plist-get it :delta)
       (plist-get it :text)))

(defun exhub-fim--claude-complete (context callback)
  "Complete code with Claude.
CONTEXT is to be used to build the prompt.  CALLBACK is the function
to be called when completion items arrive."
  (exhub-fim--with-temp-response
   (push
    (plz 'post "https://api.anthropic.com/v1/messages"
         :headers `(("Content-Type" . "application/json")
                    ("Accept" . "application/json")
                    ("x-api-key" . ,(exhub-fim--get-api-key (plist-get exhub-fim-claude-options :api-key)))
                    ("anthropic-version" . "2023-06-01"))
         :timeout exhub-fim-request-timeout
         :body
         (json-serialize
          (let ((options (copy-tree exhub-fim-claude-options)))
            `(,@(plist-get options :optional)
              :stream t
              :model ,(plist-get options :model)
              :system ,(exhub-fim--make-system-prompt (plist-get options :system))
              :max_tokens ,(plist-get options :max_tokens)
              :messages ,(vconcat
                          `(,@(exhub-fim--eval-value (plist-get options :fewshots))
                            (:role "user"
                                   :content ,(exhub-fim--make-chat-llm-shot context exhub-fim-claude-options)))))))
         :as 'string
         :filter (exhub-fim--make-process-stream-filter --response--)
         :then
         (lambda (json)
           (when-let* ((result (exhub-fim--stream-decode json #'exhub-fim--claude-get-text-fn))
                       (completion-items (exhub-fim--parse-completion-itmes-default result))
                       (completion-items (exhub-fim--filter-context-sequence-in-items
                                          completion-items
                                          context))
                       (completion-items (exhub-fim--remove-spaces completion-items)))
             ;; insert the current result into the completion items list
             (funcall callback completion-items)))
         :else
         (lambda (err)
           (exhub-fim--handle-chat-completion-timeout
            context err --response-- #'exhub-fim--claude-get-text-fn "Claude" callback)))
    exhub-fim--current-requests)))

(defun exhub-fim--gemini-get-text-fn (json)
  "Function to get the completion from a JSON object for gemini."
  (--> json
       (plist-get it :candidates)
       car
       (plist-get it :content)
       (plist-get it :parts)
       car
       (plist-get it :text)))

(defun exhub-fim--gemini-complete (context callback)
  "Complete code with gemini.
CONTEXT is to be used to build the prompt.  CALLBACK is the function
to be called when completion items arrive."
  (exhub-fim--with-temp-response
   (push
    (plz 'post (format "https://generativelanguage.googleapis.com/v1beta/models/%s:streamGenerateContent?alt=sse&key=%s"
                       (plist-get exhub-fim-gemini-options :model)
                       (exhub-fim--get-api-key (plist-get exhub-fim-gemini-options :api-key)))
         :headers `(("Content-Type" . "application/json")
                    ("Accept" . "application/json"))
         :timeout exhub-fim-request-timeout
         :body
         (json-serialize
          (let* ((options (copy-tree exhub-fim-gemini-options))
                 (fewshots (exhub-fim--eval-value (plist-get options :fewshots)))
                 (fewshots (mapcar
                            (lambda (shot)
                              `(:role
                                ,(if (equal (plist-get shot :role) "user") "user" "model")
                                :parts
                                [(:text ,(plist-get shot :content))]))
                            fewshots)))
            `(,@(plist-get options :optional)
              :system_instruction (:parts (:text ,(exhub-fim--make-system-prompt (plist-get options :system))))
              :contents ,(vconcat
                          `(,@fewshots
                            (:role "user"
                                   :parts [(:text ,(exhub-fim--make-chat-llm-shot context exhub-fim-gemini-options))]))))))
         :as 'string
         :filter (exhub-fim--make-process-stream-filter --response--)
         :then
         (lambda (json)
           (when-let* ((result (exhub-fim--stream-decode json #'exhub-fim--gemini-get-text-fn))
                       (completion-items (exhub-fim--parse-completion-itmes-default result))
                       (completion-items (exhub-fim--filter-context-sequence-in-items
                                          completion-items
                                          context))
                       (completion-items (exhub-fim--remove-spaces completion-items)))
             (funcall callback completion-items)))
         :else
         (lambda (err)
           (exhub-fim--handle-chat-completion-timeout
            context err --response-- #'exhub-fim--gemini-get-text-fn "Gemini" callback)))
    exhub-fim--current-requests)))


(defun exhub-fim--setup-auto-suggestion ()
  "Setup auto-suggestion with `post-command-hook'."
  (add-hook 'post-command-hook #'exhub-fim--maybe-show-suggestion nil t))

(defun exhub-fim--is-minuet-command ()
  "Return t if current command is a exhub-fim command."
  (and this-command
       (symbolp this-command)
       (string-match-p "^exhub-fim" (symbol-name this-command))))

(defun exhub-fim--is-not-on-throttle ()
  "Return t if current time since last time is larger than the throttle delay."
  (or (null exhub-fim--last-auto-suggestion-time)
      (> (float-time (time-since exhub-fim--last-auto-suggestion-time))
         exhub-fim-auto-suggestion-throttle-delay)))

(defun exhub-fim--maybe-show-suggestion ()
  "Show suggestion with debouncing and throttling."
  (when (and (exhub-fim--is-not-on-throttle)
             (not (exhub-fim--is-minuet-command)))
    (when exhub-fim--debounce-timer
      (cancel-timer exhub-fim--debounce-timer))
    (setq exhub-fim--debounce-timer
          (let ((buffer (current-buffer)))
            (run-with-idle-timer
             exhub-fim-auto-suggestion-debounce-delay nil
             (lambda ()
               (when (and (eq buffer (current-buffer))
                          (or (null exhub-fim--auto-last-point)
                              (not (eq exhub-fim--auto-last-point (point))))
                          (not (run-hook-with-args-until-success 'exhub-fim-auto-suggestion-block-functions)))
                 (setq exhub-fim--last-auto-suggestion-time (current-time)
                       exhub-fim--auto-last-point (point))
                 (exhub-fim-show-suggestion))))))))

(defun exhub-fim--default-fim-prompt-function (ctx)
  "Default function to generate prompt for FIM completions from CTX."
  (format "%s\n%s"
          (plist-get ctx :language-and-tab)
          (plist-get ctx :before-cursor)))

(defun exhub-fim--default-fim-suffix-function (ctx)
  "Default function to generate suffix for FIM completions from CTX."
  (plist-get ctx :after-cursor))

(defun exhub-fim--default-chat-input-language-and-tab-function (ctx)
  "Default function to get language and tab style from CTX."
  (plist-get ctx :language-and-tab))

(defun exhub-fim--default-chat-input-before-cursor-function (ctx)
  "Default function to get before cursor from CTX.
If context is incomplete, remove first line to avoid partial code."
  (let ((text (plist-get ctx :before-cursor))
        (incomplete (plist-get ctx :is-incomplete-before)))
    (when incomplete
      (setq text (replace-regexp-in-string "\\`.*\n" "" text)))
    text))

(defun exhub-fim--default-chat-input-after-cursor-function (ctx)
  "Default function to get after cursor from CTX.
If context is incomplete, remove last line to avoid partial code."
  (let ((text (plist-get ctx :after-cursor))
        (incomplete (plist-get ctx :is-incomplete-after)))
    (when incomplete
      (setq text (replace-regexp-in-string "\n.*\\'" "" text)))
    text))

(defun exhub-fim--cleanup-auto-suggestion ()
  "Clean up auto-suggestion timers and hooks."
  (remove-hook 'post-command-hook #'exhub-fim--maybe-show-suggestion t)
  (when exhub-fim--debounce-timer
    (cancel-timer exhub-fim--debounce-timer)
    (setq exhub-fim--debounce-timer nil))
  (setq exhub-fim--auto-last-point nil))

;;;###autoload
(define-minor-mode exhub-fim-auto-suggestion-mode
  "Toggle automatic code suggestions.
When enabled, Exhub-fim will automatically show suggestions while you type."
  :init-value nil
  :lighter " Exhub-fim"
  (if exhub-fim-auto-suggestion-mode
      (exhub-fim--setup-auto-suggestion)
    (exhub-fim--cleanup-auto-suggestion)))

(defvar exhub-fim-active-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-b t") #'exhub-fim-complete-with-minibuffer)
    map)
  "Keymap used when `exhub-fim-active-mode' is enabled.")

(define-minor-mode exhub-fim-active-mode
  "Activated when there is an active suggestion in exhub-fim."
  :init-value nil
  :keymap exhub-fim-active-mode-map)

;;;###autoload
(defun exhub-fim-configure-provider ()
  "Configure a exhub-fim provider interactively.
This command offers an interactive approach to configuring provider
settings, as an alternative to manual configuration via `setq' and
`plist-put'.  When selecting either `openai-compatible' or
`openai-fim-compatible' providers, users will be prompted to specify
their endpoint and API key."
  (interactive)
  (let* ((providers '(("OpenAI" . openai)
                      ("Claude" . claude)
                      ("Codestral" . codestral)
                      ("OpenAI Compatible" . openai-compatible)
                      ("OpenAI FIM Compatible" . openai-fim-compatible)
                      ("Gemini" . gemini)))
         (provider-name (completing-read "Select provider: " providers nil t))
         (provider (alist-get provider-name providers nil nil #'equal))
         (options-sym (intern (format "exhub-fim-%s-options" provider)))
         (options (symbol-value options-sym))
         (current-model (plist-get options :model))
         (model (read-string "Model: " (or current-model ""))))

    (plist-put options :model model)

    ;; For OpenAI compatible providers, also configure endpoint and API key
    (when (memq provider '(openai-compatible openai-fim-compatible))
      (let* ((current-endpoint (plist-get options :end-point))
             (current-api-key (plist-get options :api-key))
             (endpoint (read-string "Endpoint URL: " (or current-endpoint "")))
             (api-key (read-string "API Key Environment Variable or Function: "
                                   (cond ((stringp current-api-key) current-api-key)
                                         ((symbolp current-api-key) (symbol-name current-api-key))
                                         (t ""))))
             ;; If the user enters nothing via `read-string`, retain the current API key.
             (final-api-key (cond ((equal "" api-key) current-api-key)
                                  ((functionp (intern-soft api-key)) (intern-soft api-key))
                                  (t api-key))))
        (plist-put options :end-point endpoint)
        (plist-put options :api-key final-api-key)))

    (setq exhub-fim-provider provider)
    (message "Exhub-fim provider configured to %s with model %s" provider-name model)))

(provide 'exhub-fim)
;;; exhub-fim.el ends here
